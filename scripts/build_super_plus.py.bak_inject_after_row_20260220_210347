#!/usr/bin/env python3
import argparse, json, math, subprocess
from pathlib import Path
import pandas as pd
from docx import Document

def _load_news_risk_summary(ticker: str) -> dict:
    """
    Load the authoritative news/risk summary for a ticker.
    Priority: export/CANON_{T}/news_risk_summary_{T}.json, then outputs/news_risk_summary_{T}.json.
    """
    try:
        import json
        from pathlib import Path
        root = Path(__file__).resolve().parents[1]
        cand = [
            root / "export" / f"CANON_{ticker.upper()}" / f"news_risk_summary_{ticker.upper()}.json",
            root / "outputs" / f"news_risk_summary_{ticker.upper()}.json",
        ]
        for fp in cand:
            if fp.exists():
                return json.loads(fp.read_text(encoding="utf-8"))
    except Exception:
        pass
    return {}


def _na(x):
    if x is None: return True
    try:
        return isinstance(x, float) and math.isnan(x)
    except Exception:
        return False

def _pct(x, digits=2):
    if _na(x): return "N/A"
    return f"{x:.{digits}f}%"

def _money(x):
    if _na(x): return "N/A"
    x = float(x)
    sign = "-" if x < 0 else ""
    x = abs(x)
    for suf, div in [("T",1e12),("B",1e9),("M",1e6),("K",1e3)]:
        if x >= div:
            return f"{sign}${x/div:.2f}{suf}"
    return f"{sign}${x:.0f}"

def _xmult(x):
    if _na(x): return "N/A"
    return f"{float(x):.2f}x"

def _load_canon_risk(T: str):
    """Load authoritative news/risk summary from CANON (if present)."""
    try:
        from pathlib import Path
        import json
        canon = Path(f"export/CANON_{T.upper()}")
        fp = canon / f"news_risk_summary_{T.upper()}.json"
        if fp.exists():
            return json.loads(fp.read_text(encoding="utf-8"))
    except Exception:
        pass
    return {}


def _load_row(ticker: str):
    p = Path("data/processed/comps_snapshot.csv")
    df = pd.read_csv(p)
    df["ticker"] = df["ticker"].astype(str).str.upper()
    r = df[df["ticker"] == ticker]
    if r.empty:
        raise ValueError(f"Ticker {ticker} not found in {p}")
    return r.iloc[0].to_dict()

def _load_json(path: Path, default=None):
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return default

def _band_label(val, good_lo=None, ok_lo=None, bad_hi=None, direction="high_good"):
    """
    direction:
      - high_good: higher is better (growth, margins, yields)
      - low_good: lower is better (debt multiples, risk counts)
    """
    if _na(val):
        return "UNKNOWN ‚ùì"
    v = float(val)

    if direction == "high_good":
        # good if >= good_lo, ok if >= ok_lo, else bad
        if good_lo is not None and v >= good_lo: return "GOOD ‚úÖ"
        if ok_lo is not None and v >= ok_lo: return "OK üü°"
        return "BAD ‚ùå"
    else:
        # good if <= good_lo, ok if <= ok_lo, else bad
        if good_lo is not None and v <= good_lo: return "GOOD ‚úÖ"
        if ok_lo is not None and v <= ok_lo: return "OK üü°"
        return "BAD ‚ùå"

def _safe_get(row, key):
    return row.get(key, None)

def _derive_fcf_yield_pct(row):
    fy = row.get("fcf_yield_pct")
    if not _na(fy): return float(fy)
    fy2 = row.get("fcf_yield")  # sometimes stored as decimal
    if not _na(fy2):
        try:
            fy2 = float(fy2)
            # if it looks like 0.0643 -> 6.43%
            if fy2 <= 1.5:
                return fy2 * 100.0
            return fy2
        except Exception:
            return None
    return None

def _read_score_rating_veracity(ticker: str):
    # best effort: use outputs/veracity_{T}.json if present
    v = _load_json(Path(f"outputs/veracity_{ticker}.json"), {})
    score = v.get("score") or v.get("model_score") or v.get("overall_score")
    rating = v.get("rating") or v.get("model_rating") or v.get("verdict")
    veracity = v.get("veracity") or v.get("confidence") or v.get("evidence_score")
    return score, rating, veracity

def _load_thesis(thesis_path: Path):
    t = _load_json(thesis_path, {})
    headline = t.get("name") or t.get("headline") or f"{t.get('ticker','')}: Thesis"
    desc = t.get("description") or t.get("thesis") or ""
    claims = t.get("claims") or t.get("rules") or []
    return headline, desc, claims

def _claim_actuals_map(row):
    # map claim metric names -> actual values from comps_snapshot
    return {
        "latest_revenue_yoy_pct": row.get("revenue_ttm_yoy_pct"),
        "revenue_ttm_yoy_pct": row.get("revenue_ttm_yoy_pct"),
        "latest_free_cash_flow": row.get("fcf_ttm"),
        "free_cash_flow": row.get("fcf_ttm"),
        "fcf_ttm": row.get("fcf_ttm"),
        "latest_fcf_margin_pct": row.get("fcf_margin_ttm_pct"),
        "fcf_margin_ttm_pct": row.get("fcf_margin_ttm_pct"),
        "fcf_yield_pct": _derive_fcf_yield_pct(row),
        # news/risk metrics may exist elsewhere; keep as None if we can't find
        "news_shock_30d": rs.get("news_shock_30d"),
        "risk_insurance_neg_30d": rs.get("risk_insurance_neg_30d"),
        "risk_regulatory_neg_30d": rs.get("risk_regulatory_neg_30d"),
        "risk_labor_neg_30d": rs.get("risk_labor_neg_30d"),
    }

def _compare(op: str, actual, thresh):
    if _na(actual) or _na(thresh): return None
    a = float(actual); t = float(thresh)
    if op == ">=": return a >= t
    if op == ">":  return a >  t
    if op == "<=": return a <= t
    if op == "<":  return a <  t
    if op == "==": return a == t
    return None

def _write_docx(md_lines, docx_path: Path, title: str):
    doc = Document()
    doc.add_heading(title, level=1)

    for ln in md_lines:
        ln = ln.rstrip("\n")
        if not ln:
            doc.add_paragraph("")
            continue
        if ln.startswith("## "):
            doc.add_heading(ln[3:], level=2)
            continue
        if ln.startswith("### "):
            doc.add_heading(ln[4:], level=3)
            continue
        if ln.startswith("- "):
            doc.add_paragraph(ln[2:], style="List Bullet")
            continue
        doc.add_paragraph(ln)

    doc.save(str(docx_path))

def _export_pdf(docx_path: Path):
    soffice = Path("/opt/homebrew/bin/soffice")
    if not soffice.exists():
        return None
    outdir = docx_path.parent
    subprocess.run([str(soffice), "--headless", "--convert-to", "pdf", "--outdir", str(outdir), str(docx_path)],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    pdf = docx_path.with_suffix(".pdf")
    return pdf if pdf.exists() else None

def main(ticker: str, thesis_path: Path):
    rs = _load_news_risk_summary(ticker)
    T = ticker.upper()
    row = _load_row(T)

    score, rating, veracity = _read_score_rating_veracity(T)
    headline, desc, claims = _load_thesis(thesis_path)

    # Core metrics from comps_snapshot
    rev_yoy = row.get("revenue_ttm_yoy_pct")
    fcf_ttm = row.get("fcf_ttm")
    fcf_margin = row.get("fcf_margin_ttm_pct")
    fcf_yield_pct = _derive_fcf_yield_pct(row)
    mcap = row.get("market_cap")
    cash = row.get("cash")
    debt = row.get("debt")
    net_debt = row.get("net_debt")
    net_debt_to_fcf = row.get("net_debt_to_fcf_ttm")

    md = []
    md.append(f"SUPER+ Investment Memo ‚Äî {T}")
    md.append(f"*Generated: {pd.Timestamp.utcnow():%Y-%m-%d %H:%M UTC}*")
    md.append("")
    md.append("## 1) Your thesis (what you believe)")
    md.append(f"**{headline}**")
    md.append(desc if desc else "(No thesis text provided)")
    md.append("")
    md.append("## 2) What the model concluded (plain English)")
    md.append(f"- **Rating:** **{rating if rating else 'N/A'}** (score **{score if score is not None else 'N/A'}/100**)")
    md.append(f"- **Evidence confidence / veracity:** **{veracity if veracity is not None else 'N/A'}** (higher = more trustworthy coverage)")
    md.append("")
    md.append("## 3) The 30-second explanation (for total beginners)")
    md.append("Think of this like a **car dashboard**:")
    md.append("- The **score** is the overall attractiveness estimate.")
    md.append("- The **buckets** explain *why* the score happened.")
    md.append("- The **news/risk** items try to spot headline landmines.")
    md.append("- The **thesis test** checks whether the facts match the story you‚Äôre betting on.")
    md.append("")

    # ===== Linked cheat sheet (rule band + today's value + verdict) =====
    md.append("## Good vs Bad cheat-sheet (linked to this ticker)")
    md.append("Each line shows: **rule band** ‚Üí **today‚Äôs value** ‚Üí **verdict**.")
    md.append("")

    cheat = [
        ("Revenue growth compared to last year",
         "Usually good: > +10% | OK: 0% to +10% | Usually bad: < 0%",
         rev_yoy, _pct(rev_yoy), _band_label(rev_yoy, good_lo=10, ok_lo=0, direction="high_good")),
        ("Free cash flow over the last 12 months",
         "Good: positive | Bad: negative",
         fcf_ttm, _money(fcf_ttm), ("GOOD ‚úÖ" if (not _na(fcf_ttm) and float(fcf_ttm) > 0) else ("BAD ‚ùå" if not _na(fcf_ttm) else "UNKNOWN ‚ùì"))),
        ("Free cash flow margin",
         "Usually good: ‚â• 10% | OK: 3% to 10% | Bad: ‚â§ 0%",
         fcf_margin, _pct(fcf_margin), _band_label(fcf_margin, good_lo=10, ok_lo=3, direction="high_good")),
        ("Free cash flow yield (cash vs what you pay for the stock)",
         "Often cheap: > 5% | Neutral: 2% to 5% | Often expensive: < 2%",
         fcf_yield_pct, _pct(fcf_yield_pct), _band_label(fcf_yield_pct, good_lo=5, ok_lo=2, direction="high_good")),
        ("Net debt divided by free cash flow (years-to-pay debt)",
         "Good: < 3x | Watch: 3x to 6x | High risk: > 6x",
         net_debt_to_fcf, _xmult(net_debt_to_fcf), _band_label(net_debt_to_fcf, good_lo=3, ok_lo=6, direction="low_good")),
    ]

    for title, rule, raw, disp, verdict in cheat:
        md.append(f"### {title}")
        md.append(f"- **Rule band:** {rule}")
        md.append(f"- **{T} today:** **{disp}** ‚Üí **{verdict}**")
        md.append("")

    md.append("## 4) Core numbers (sanity-check)")
    md.append(f"- Revenue growth compared to last year: **{_pct(rev_yoy)}**  _(source: comps_snapshot ‚Üí revenue_ttm_yoy_pct)_")
    md.append(f"- Free cash flow over the last 12 months: **{_money(fcf_ttm)}**  _(source: comps_snapshot ‚Üí fcf_ttm)_")
    md.append(f"- Free cash flow margin: **{_pct(fcf_margin)}**  _(source: comps_snapshot ‚Üí fcf_margin_ttm_pct)_")
    md.append(f"- Free cash flow yield: **{_pct(fcf_yield_pct)}**  _(source: comps_snapshot ‚Üí fcf_yield_pct / fcf_yield)_")
    md.append("")

    md.append("## 5) Balance sheet snapshot (why debt matters)")
    md.append(f"- Market cap: **{_money(mcap)}**")
    md.append(f"- Cash: **{_money(cash)}**")
    md.append(f"- Debt: **{_money(debt)}**")
    md.append(f"- Net debt: **{_money(net_debt)}** _(debt minus cash)_")
    md.append(f"- Net debt divided by free cash flow: **{_xmult(net_debt_to_fcf)}** _(how many years of cash it takes to pay debt)_")
    md.append("")

    # Thesis test with PASS/FAIL using what we can actually compute
    md.append("## 6) Thesis test (PASS/FAIL with actual numbers)")
    actuals = _claim_actuals_map(row)

    if not claims:
        md.append("- No claim rules were provided in this thesis file.")
    else:
        for c in claims:
            metric = c.get("metric") or c.get("field")
            op = c.get("op") or c.get("operator") or ">="
            thr = c.get("threshold")
            label = c.get("label") or c.get("text") or metric

            act = actuals.get(metric)
            res = _compare(op, act, thr)
            if res is True:
                status = "PASS ‚úÖ"
            elif res is False:
                status = "FAIL ‚ùå"
            else:
                status = "UNKNOWN ‚ùì"

            # pretty display
            if metric in ("latest_free_cash_flow","fcf_ttm","free_cash_flow"):
                act_disp = _money(act)
                thr_disp = _money(thr) if not _na(thr) else "N/A"
            elif metric and "pct" in metric:
                act_disp = _pct(act)
                thr_disp = _pct(thr)
            else:
                act_disp = "N/A" if _na(act) else str(act)
                thr_disp = "N/A" if _na(thr) else str(thr)

            md.append(f"- **{status}** ‚Äî {label}")
            md.append(f"  - rule: `{metric}` {op} {thr_disp}")
            md.append(f"  - actual: **{act_disp}**")
    md.append("")

    # Thesis-specific guidance (your ‚Äúdrivers become employees‚Äù risk)
    md.append("## 7) If your thesis is about drivers becoming employees (what would break first)")
    md.append("- **Costs go up fast** (wages, benefits, payroll taxes, scheduling, compliance).")
    md.append("- That usually hits **free cash flow margin** first, then **free cash flow**.")
    md.append("- You‚Äôd expect: **labor/regulatory headlines increase**, and the market may re-rate the stock down.")
    md.append("- What to watch weekly: **labor/regulatory risk headlines**, any court/ballot actions, and updates in filings/earnings about classification rules.")
    md.append("")

    md.append("## 8) What to open (dopamine mode)")
    md.append(f"- Dashboard: `outputs/decision_dashboard_{T}.html`")
    md.append(f"- News clickpack: `outputs/news_clickpack_{T}.html`")
    md.append(f"- Alerts: `outputs/alerts_{T}.json`")
    md.append(f"- Claim evidence: `outputs/claim_evidence_{T}.html`")
    md.append("")

    md_text = "\n".join(md) + "\n"

    out_md = Path("outputs") / f"{T}_SUPER_PLUS_Memo.md"
    out_docx = Path("export") / f"{T}_SUPER_PLUS_Memo.docx"
    out_md.write_text(md_text, encoding="utf-8")

    _write_docx(md, out_docx, f"SUPER+ Investment Memo ‚Äî {T}")
    pdf = _export_pdf(out_docx)

    print("DONE ‚úÖ SUPER+ memo created:")
    print(f"- {out_md}")
    print(f"- {out_docx}")
    if pdf:
        print(f"- {pdf}")
    else:
        print("‚ö†Ô∏è PDF not created (soffice missing or failed). DOCX still created.")

if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("--ticker", required=True)
    ap.add_argument("--thesis", required=True)
    args = ap.parse_args()
    main(args.ticker, Path(args.thesis))
